\chapter{Testing}

% Test Plan: A document describing the scope, approach, resources and schedule of intended test activities. It identifies amongst others test items, the features to be tested, the testing tasks, who will do each task, degree of tester independence, the test environment, the test design techniques and entry and exit criteria to be used, and the rationale for their choice,and any risks requiring contingency planning. It is a record of the test planning process.
% Test Cases
% Test Results

\section{Test Plan}
\paragraph{}
This is a document describing the testing scope and activities. It is the basis for formally testing components of this software project.
%
\subsection{Scope}
%<What all is going to be tested>
\paragraph{}
Testing will be performed only on functional components of the system. These include the two main modules corresponding to Tier I and Tier II. Besides this, we don't yet have a plan to perform any other non-functional tests. This testing strategy suffices, as the project itself is not very vast. Listing more formally, the components to be tested are:
\begin{enumerate}
\item Module I (Tier I)
	\begin{enumerate}
	\item Web API for device control.
	\item Individual functions involved in maintaining device state changes and reporting them to Module II.
	\end{enumerate}
\item Module II (Tier II)
	\begin{enumerate}
	\item Web API for Learning Service.
	\item Individual functions involved in data accumulation and learning process.
	\end{enumerate}
\end{enumerate}

\subsection{Not in Scope}
%<What all is NOT going to be tested - how the client views the WebUI, conformance of inter-tier interfaces to standards>
%<Why - not very relevant to the core idea being demonstrated, unnecessary for this demonstration>
\paragraph{}
We won't be performing any tests to verify if the users interfaces are satisfactory and convenient for the user. This doesn't form a core part of the idea that we are trying to demonstrate through this project.
\paragraph{}
This test plan also doesn't include any tests for verifying conformance of the implemented APIs to any particularly defined interface standards. Again, this hinders the simplicity of demonstration of the intended idea - involving a combined application of SaaS, IoT, and ML to solve the problem of home automation using predictive learning.
\paragraph{}
Below is a list of things that have been declared out of scope for this test, for the reasons stated above:
\begin{enumerate}
\item User Interface Testing.
\item Testing conformance of components (especially the web APIs) to set standards.
\end{enumerate}

\subsection{Assumptions}
%<All the conditions that need to hold true for us to be able to proceed successfully - client-tier I network always available>
\paragraph{}
We need to make certain assumptions regarding the environment we operate in, and the tests we cannot perform - for reasons that otherwise deem development, testing and operation impractical to achieve. This can be a long list if each minute detail is taken into account, so we need to limit it to the core hardware and software components that directly impact us. Some of these assumption are:
\begin{enumerate}
\item The network infrastructure connecting the Clients to Tier I will always be available.
\item The clients themselves will always have access to suitable devices that will be used to connect to the automation system.
\item Connection between the Tier I application and the Tier II service will be available most of the time. Occasional unavailability of Tier II service is tolerable.
\item There are no security threats that need to be addressed within the house-wide network that the client, Tier I and Tier II are all a part of.
\end{enumerate}

\subsection{Environment}
%<What kind of environment requirements exist. The software and hardware used for testing.>
\paragraph{}
Modules I and II will have to be tested independently. This will be done by performing pre-designed unittests. Each individual component (that is to say, each "function") will be tested by passing a value to it and checking if the returned value matches expected value. Module I will be hosted on the Raspberry Pi, that is the controller; while Module II will be hosted on the PC, and provide learning service to Module I.
\paragraph{}
Each test case is intended to be executed on the device that will host the component being tested. This will keep the test environment and usage environment consistent, leading to more robust tests. The developed tests will have to be run manually, as we don't plan on automating these tests.

\subsection{Tools}
%<Tools used to test the code. Python's unittest library, in this case.>
\paragraph{}
Due to the simplicity of this project, we will not be using any sophisticated test or result management software to keep track of tests. The entire test code will be developed using just one Python language tool - the unittest library. The unittest library is the default testing library that comes with the standard library itself. We will be using this to make sure the components behave the way we expect them to.

\subsection{Exit Criteria}
%<When to stop testing - when tests for all "units" are satisfied.>
\paragraph{}
The exit criteria for the test will be simple - success for all tests implies end of testing. Conformance of all components to the test criteria will be necessary to signal an exit from the tests.

\newpage
\section{Test Cases}
%<Define cases for each "unit" that is within scope of testing>
% Template for the test cases
\begin{comment}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
Module & <module\#> \\
\hline
Unit name & <name of unit> \\
\hline
Preconditions & <preconditions> \\
\hline
Test Steps & \begin{enumerate}
\item <first step>
\item <second step>
\end{enumerate}\\
\hline
Expected Results & <expected results> \\
\hline
\end{tabular}
\\
\end{comment}
% Template ends

\subsection{Unit Test Cases}
\paragraph{}
Each module will have its own set of test cases for each of the components it contains.\\\\
%Module1: InterfaceBackend.startPage, InterfaceBackend.reqSwitch, SmartDevice.switch
%Module2: datasetRead, startPage, changeTo, generate, predict
%
%Module1 starts
%
%InterfaceBackend.startPage
\addcontentsline{lot}{table}{Unit Test Cases for $startPage()$}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
Module & Module\#1 \\
\hline
Unit name & InterfaceBackend.startPage() \\
\hline
Arguments & $None$. \\
\hline
\vspace*{\baselineskip}Test Steps & \begin{enumerate}
\item Invoke function without any arguments.
\item Check if page is displayed properly.
\end{enumerate}\\
\hline
\vspace*{\baselineskip}Expected Returned Values & \begin{enumerate}
\item Nothing is returned by the function to the caller.
\item A web page containing the controls for the smart devices is displayed.
\end{enumerate} \\
\hline
\end{tabular}
\\[2\baselineskip]
%
%InterfaceBackend.reqSwitch
\addcontentsline{lot}{table}{Unit Test Cases for $reqSwitch()$}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
Module & Module\#1 \\
\hline
Unit name & InterfaceBackend.reqSwitch() \\
\hline
\vspace*{\baselineskip}Arguments & \begin{enumerate}
\item Device name - a $String$.
\item New device state - a $String$.
\end{enumerate} \\
\hline
\vspace*{\baselineskip}Test Steps & \begin{enumerate}
\item[] Case 1: Invoke function with valid device name ($b1/b2/b3$) and valid state ($ON/OFF$).
\item[] Case 2: Invoke function with invalid device name and valid state.
\item[] Case 3: Invoke function with valid device name and invalid state.
\end{enumerate}\\
\hline
\vspace*{\baselineskip}Expected Returned Values & \begin{enumerate}
\item[] Case 1: The string ``$ON'' or ``OFF$''.
\item[] Case 2: The string ``Bulb $bulb\_name$ does not exist.''
\item[] Case 3: The string ``$new\_state$ is not a valid state.''
\end{enumerate} \\
\hline
\end{tabular}
\\[2\baselineskip]
%
%SmartDevice.switch
\addcontentsline{lot}{table}{Unit Test Cases for $switch()$}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
Module & Module\#1 \\
\hline
Unit name & SmartDevice.switch() \\
\hline
Arguments & New state - a $String$. \\
\hline
\vspace*{\baselineskip}Test Steps & \begin{enumerate}
\item[] Case1: Invoke function with a valid state.
\item[] Case2: Invoke function with an invalid state.
\end{enumerate}\\
\hline
\vspace*{\baselineskip}Expected Returned Values & \begin{enumerate}
\item[] Case 1: Pin changes state.
\item[] Case 2: Pin doesn't change state.
\end{enumerate} \\
\hline
\end{tabular}
\\[2\baselineskip]
%
%Module2 starts
%
%datasetRead
\addcontentsline{lot}{table}{Unit Test Cases for $datasetRead()$}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
Module & Module\#2 \\
\hline
Unit name & datasetRead() \\
\hline
Arguments & $None$ \\
\hline
\vspace*{\baselineskip}Test Steps & \begin{enumerate}
\item Invoke the function without any arguments.
\item Verify if dataset file is read correctly.
\end{enumerate}\\
\hline
Expected Returned Values & An object of type $pandas.core.frame.DataFrame$ \\
\hline
\end{tabular}
\\[2\baselineskip]
%
%startPage
\addcontentsline{lot}{table}{Unit Test Cases for $startPage()$}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
Module & Module\#2 \\
\hline
Unit name & startPage() \\
\hline
Arguments & $None$ \\
\hline
\vspace*{\baselineskip}Test Steps & \begin{enumerate}
\item Invoke the function without any arguments.
\item Verify if the expected message is returned.
\end{enumerate}\\
\hline
Expected Returned Values & The String ``$PC\ side\ server\ is\ up\ and\ running!$''\\
\hline
\end{tabular}
\\[2\baselineskip]
%
%changeTo
\addcontentsline{lot}{table}{Unit Test Cases for $changeTo()$}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
Module & Module\#2 \\
\hline
Unit name & changeTo() \\
\hline
\vspace*{\baselineskip}Arguments & \begin{enumerate}
\item Device name - a $String$.
\item New device state - a $String$.
\end{enumerate} \\
\hline
\vspace*{\baselineskip}Test Steps & \begin{enumerate}
\item[] Case 1: Invoke function with valid device name ($b1/b2/b3$) and valid state ($ON/OFF$).
\item[] Case 2: Invoke function with invalid device name and valid state.
\item[] Case 3: Invoke function with valid device name and invalid state.
\end{enumerate}\\
\hline
\vspace*{\baselineskip}Expected Returned Values & \begin{enumerate}
\item[] Case 1: The string ``Bulb $b1/b2/b3$ is now $ON/OFF$.''
\item[] Case 2: The string ``Bulb $bulb\_name$ does not exist.''
\item[] Case 3: The string ``$new\_state$ is not a valid state.''
\end{enumerate} \\
\hline
\end{tabular}
\\[2\baselineskip]
%
%generate
\addcontentsline{lot}{table}{Unit Test Cases for $generate()$}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
Module & Module\#2 \\
\hline
Unit name & generate() \\
\hline
Arguments & Device name - a $String$. \\
\hline
\vspace*{\baselineskip}Test Steps & \begin{enumerate}
\item[] Case1: Invoke function with the name of an existing device.
\item[] Case2: Invoke function with the name of a non-existent device.
\end{enumerate}\\
\hline
\vspace*{\baselineskip}Expected Returned Values & \begin{enumerate}
\item[] Case 1: The string ``Model generated and dumped.''
\item[] Case 2: The string ``Generate error: $bulb\_name$ is not a bulb''
\end{enumerate} \\
\hline
\end{tabular}
\\[2\baselineskip]
%
%predict
\addcontentsline{lot}{table}{Unit Test Cases for $predict()$}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
Module & Module\#2 \\
\hline
Unit name & predict() \\
\hline
Arguments & Device name - a $String$. \\
\hline
\vspace*{\baselineskip}Test Steps & \begin{enumerate}
\item[] Case1: Invoke function with the name of an existing device.
\item[] Case2: Invoke function with the name of a non-existent device.
\end{enumerate}\\
\hline
\vspace*{\baselineskip}Expected Returned Values & \begin{enumerate}
\item[] Case 1: Either of the strings ``ON'' or ``OFF''.
\item[] Case 2: The string ``Unavailable''
\end{enumerate} \\
\hline
\end{tabular}
\\[2\baselineskip]

\newpage
\section{Test Results}
%<Expected vs Actual>
\subsection{Module 1}
\addcontentsline{lot}{table}{Unit Test Results for Module 1}
\begin{tabular}{|p{2.3cm}|p{5cm}|p{5cm}|p{1.2cm}|}
\hline
\textbf{Unit name} & \textbf{Expected Return Value} & \textbf{Actual Return Value} & \textbf{Result} \\
\hline
\vspace*{\baselineskip}ib.startPage() & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: Nothing should be returned by the function to the caller.
\item[] \hspace*{-1cm}Case 2: A web page containing the controls for the smart devices should be displayed.
\end{enumerate} & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: Nothing is returned by the function to the caller.
\item[] \hspace*{-1cm}Case 2: A web page containing the controls for the smart devices is displayed.
\end{enumerate} & \vspace*{\baselineskip}OK \\
\hline
\vspace*{\baselineskip}ib.reqSwitch() & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: Either of the strings ``ON'' or ``OFF'' should be returned to the caller.
\item[] \hspace*{-1cm}Case 2: An error message saying the requested bulb doesn't exist.
\item[] \hspace*{-1cm}Case 3: An error message saying the new state is not a valid state.
\end{enumerate} & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: ``Bulb b1 is now ON.''
\item[] \hspace*{-1cm}Case 2: The string ``Bulb $bulb\_name$ does not exist.'' is returned.
\item[] \hspace*{-1cm}Case 3: The string ``$new\_state$ is not a valid state.'' is returned.
\end{enumerate} & \vspace*{\baselineskip}OK \\
\hline
\vspace*{\baselineskip}b1.switch() & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: The state of the pin associated with the object $b1$ should change.
\item[] \hspace*{-1cm}Case 2: The state of the pin associated with the object $b1$ should be unchanged.
\end{enumerate} & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: The state of the pin associated with the object $b1$ changes.
\item[] \hspace*{-1cm}Case 2: The state of the pin associated with the object $b1$ remains unchanged.
\end{enumerate} & \vspace*{\baselineskip}OK \\
\hline
\end{tabular}
\paragraph{}
For performing the above tests, we've used class instances to test the functions of the respective classes. The object $ib$ is an instance of the class $InterfaceBackend$; while the object $b1$ is an instance of the class $SmartDevice$.

\subsection{Module 2}
\addcontentsline{lot}{table}{Unit Test Results for Module 2}
%\begin{tabular}{|p{1.75cm}|p{5cm}|p{5cm}|p{1.25cm}|}
\begin{tabular}{|p{2.25cm}|p{5cm}|p{5cm}|p{1.25cm}|}
\hline
\textbf{Unit name} & \textbf{Expected Return Value} & \textbf{Actual Return Value} & \textbf{Result} \\
\hline
predict() & An object of type $DataFrame$ & An object of type $DataFrame$ & OK \\
\hline
startPage() & ``PC side server is up and running'' & ``PC side server is up and running'' & OK \\
\hline
\vspace*{\baselineskip}changeTo() & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: ``Bulb b1 is now ON.''
\item[] \hspace*{-1cm}Case 2: ``Bulb b4 does not exist.''
\item[] \hspace*{-1cm}Case 3: ``ONN is not a valid state.''
\end{enumerate} & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: ``Bulb b1 is now ON.''
\item[] \hspace*{-1cm}Case 2: ``Bulb b4 does not exist.''
\item[] \hspace*{-1cm}Case 3: ``ONN is not a valid state.''
\end{enumerate} & \vspace*{\baselineskip}OK \\
\hline
\vspace*{\baselineskip}generate() & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: ``Model generated and dumped.''
\item[] \hspace*{-1cm}Case 2: ``Generate error: b4 is not a bulb''
\end{enumerate} & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: ``Model generated and dumped.''
\item[] \hspace*{-1cm}Case 2: ``Generate error: b4 is not a bulb''
\end{enumerate} & \vspace*{\baselineskip}OK \\
\hline
\vspace*{\baselineskip}predict() & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: ``ON'' or ``OFF''
\item[] \hspace*{-1cm}Case 2: ``Unavailable''
\end{enumerate} & \begin{enumerate}
\item[] \hspace*{-1cm}Case 1: ``ON'' or ``OFF''
\item[] \hspace*{-1cm}Case 2: ``Unavailable''
\end{enumerate} & \vspace*{\baselineskip}OK \\
\hline
%\captionof{table}{Unit Test Results for Module 2}
\end{tabular}